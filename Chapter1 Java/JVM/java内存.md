# 第1讲：Java内存区域

## 1.运行时数据区

![jvm数据区](https://markdown-image-upload.oss-cn-beijing.aliyuncs.com/img/jvm%E6%95%B0%E6%8D%AE%E5%8C%BA.png)

- 程序计数器

  > 当前线程执行的字节码的行号指示器

  每条线程都有独立的程序计数器，各线程之间计数器互不影响，独立存储。

  如果执行的是java方法，计数器记录正在执行的虚拟机字节码指令的位置；

  如果执行的是native方法，计数器值为空（undefined）

- 虚拟机栈

  每个方法在执行的同时会创建一个栈帧，用于**存储局部变量表**，操作数栈，动态链接，方法出入口等信息。

  一个方法从调用到执行完成就对应栈帧从入栈到出栈。

  两种异常：

  1. 线程请求栈深度大于虚拟机允许的最大深度，StackOverFlowError
  2. 如果虚拟机允许栈动态拓展，且在拓展时无法申请到足够内存，抛出OutOfMemoryError

- 堆

  > 唯一目的，存放对象实例，也称为GC堆

  是GC管理的主要区域

- 方法区

  > 存储已被虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等数据

  方法区是JVM的一种规范，落地可能是不同的实现

  `PermGen space` 是 JDK7及之前， HotSpot 虚拟机 对 `方法区` 的一个落地实现。在JDK8被移除。

  `Metaspace`（元空间）是 JDK8及之后， HotSpot 虚拟机 对 `方法区` 的新的实现。

  **元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存**。

  当方法区无法满足内存分配要求，抛出OutOfMemoryError



### **对象初始化过程**

![对象初始化](https://markdown-image-upload.oss-cn-beijing.aliyuncs.com/img/%E5%AF%B9%E8%B1%A1%E5%88%9D%E5%A7%8B%E5%8C%96.png)

### 对象的内存布局

> 对象在内存中存储的布局可以分为三块区域：对象头（Header），实例数据（Instance Data），对齐填充（Padding）

- 对象头

  分为两部分信息：一部分用于存储对象自身的运行时数据，如哈希码，GC分代年龄，锁状态标志，线程持有的锁，偏向线程的ID，偏向时间戳等，称之为Mark Word

  